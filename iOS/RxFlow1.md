번역) RxFlow Part 1: In Theory
===
원문: https://twittemb.github.io/swift/coordinator/rxswift/rxflow/reactive%20programming/2017/11/08/rxflow-part-1-in-theory/
- [번역) RxFlow Part 2: In Practice](https://github.com/ydh1304/knowledge/blob/master/iOS/RxFlow2.md)
- [번역) RxFlow Part 3: Tips and Tricks](https://github.com/ydh1304/knowledge/blob/master/iOS/RxFlow3.md)

**RxFlow**는 iOS 어플리캐이션 안에 반응형 흐름 코디네이터(Reactive Flow Coordinator)를 구현합니다. **RxFlow**는 RxSwiftCommunity가 지원하는 프로잭트 입니다.

## The facts ##

iOS 어플리캐이션에서 네비게이션을 고려할 때, 두가지 선택지가 가능합니다.
- 애플과 Xcode가 재공하는 내장 메커니즘을 사용합니다. - 스토리보드, 세그웨이
- 코드 안에 커스텀 메커니즘을 구현합니다.

이 두가지의 단점은 다음과 같습니다.

- 내장 메커니즘: 네비게이션이 비교적 정적이고 스토리보드가 방대합니다. 네비게이션 코드가 뷰컨트롤러를 오염시킵니다.
- 커스텀 메커니즘: 코드 설정하기 어려울 수 있고, 선택된 디자인 패턴에 따라 복잡해 질 수 있습니다. (Router, Coordinator)

**RxFlow**는 다음을 목표로 합니다.

- 뷰컨트롤러의 협동과 재사용성을 위해 스토리보드를 아토믹 유닛으로 자릅니다.
- 네비개이션 컨텍스트에 따라 다른 방식으로 뷰컨트롤러를 보여줄 수 있게 합니다.
- 의존성 주입의 구현을 쉽게 합니다.
- 뷰컨트롤러에서 네비게이션 메커니즘을 지웁니다.
- 네비게이션 케이스들의 주소를 지정하면서 네비게이션을 선언적 방식으로 표현합니다.
- 어플리케이션을 네비게이션의 논리 블록들로 자르도록 촉진합니다.

## 스토리보드에서 코디네이터 패턴으로 ##
내 경험이 iOS 개발자 (안드로이드 또는 웹 앱 개발자는 물론)로 성장함에 따라 계속해서 네비게이션과 관련하여 동일한 문제에 직면했습니다. 다른 모든 개념적 이슈에서, 흔한 아키텍처 문제들과 관심사 요구사항을 해결하기 위한 많은 패턴들이 있었습니다.

하지만 네비게이션을 디자인 할 때 마다 문제가 생겼습니다.
- 스토리보드/세그웨이에서 의존성 주입을 어떻게하지?
- 어플리캐이션의 흐름을 어떻게 컨트롤하지?
- 네비게이션 보일러플레이트 코드를 어떻게 컨트롤러에서 제거하지?

시간이 흐러면서, 나의 iOS 앱에 대한 개념은 하나의 스토리보드를 사용하는 MVC에서 여러개의 스토리보드를 사용하는 MVC를 거쳐 마침내 최신의 가장 좋은 패턴중의 하나라고 할 수 있는 흐름 코디네이터(Flow Coordinator) 를 사용하는 MVVM에 도달했습니다. 그것은 의존성 주입, 뷰컨트롤러 재사용성, 테스트를 가능하게 했습니다. 나는 이 패턴을 크고 복잡한 어플리케이션에 적용할 기회가 있었지만 결국에는 여전히 몇가지 이슈가 나를 괴롭혔습니다.

- 항상 반복해서 코디네이터 패턴을 작성해야 했습니다.
- 뷰모델이 코디네이터와 소통하기 위해서 많은 델리개이션 패턴들을 사용해야 했습니다. 
- 나는 Redux 패턴, 특히 네비게이션 상태 메커니즘을 살펴보기 시작했습니다. 우리는 RxSwift Observables로 노출된 글로벌 네비게이션 상태를 가질 수 있으며, 이 상태를 듣고 네비게이션을 유도 할 수 있습니다. 방해가 되는 유일한 사실은 이 탐색 상태의 유일성과 그것이 가질 수 있는 통제되지 않은 책임과 저장할 수 있는 방대한 데이터 뿐이었습니다.

네비게이션이 단계적으로 변경될 수 있는 상태의 반영일 뿐이라는 아이디어가 떠오르기 시작했습니다. 하나의 장소에 저장되지 않고 앱 전체에 확산되며 그것에 반응할 수 있는 옵저버에 의해 통합될 수 있고 결과적으로 네비게이션을 유도하는 상태입니다. 이 기사의 뒷부분에서, 앱 안에 확산된 이 작은 상태는 **Step** 이라고 불리고, 옵저버는 **Coordinator**라고 불립니다.

**RxFlow**는 그 모든 경험에서 태어 났으며 코디네이터 패턴에서 유래 한 두 가지 주요 관심사를 다루었습니다.
- 개발자는 코디네이터를 더 이상 작성하지 않습니다. 네비게이션과 반응할 상태만 정의합니다.
- 스테이트가 RxSwift 옵저버블이기 때문에 델리게이션은 더 이상 필요하지 않습니다.

# 핵심 원칙 #

코디네이터 패턴에 대해 더 자세히 알고 싶다면 [코디네이터 Redux](http://khanlou.com/2015/10/coordinators-redux/) 기사를 살펴 보는 것이 좋습니다 .

코디네이터 패턴은 매우 훌륭한 아키텍처이지만 몇 가지 단점이 있습니다.

- 응용 프로그램을 부트스트랩 할 때마다 코디네이션 메커니즘을 작성해야합니다.
- 코디네이터와 통신하게 해주는 델리게이션 패턴 때문에 많은 보일러플레이트 코드가 있을 수 있습니다.

RxFlow는 코디네이터 패턴의 리액티브 구현입니다. 이 아키텍처는 많은 뛰어난 기능을 갖추고 있지만 몇 가지 개선 사항을 소개합니다.

- 네비게이션을 더 선언적으로 만듭니다.
- 선언한 네비게이션 흐름을 처리하는 내장된 코디네이터를 제공합니다.
- 반응형 프로그래밍을 사용하여 코디네이터 이슈와의 커뮤니케이션을 해결합니다.

RxFlow를 이해하기 위해 익숙해져야하는 6가지 용어가 있습니다.

- **Flow**: 각 Flow는 응용 프로그램 내의 네비게이션 영역을 정의합니다. 이것은 네비게이션 동작을 선언하는 곳입니다 (예: UIViewController 또는 다른 Flow 프리젠트)
- **Step**: 각 Step는 애플리케이션의 탐색 상태입니다. Flow과 Step의 결합은 모든 가능한 네비게이션 동작을 설명합니다. Step은 Flow에 선언 된 화면에 전달 될 내부 값 (예: Id, URL 등)을 포함 할 수도 있습니다.
- **Stepper**: Step을 방출 할 수 있는 모든 것이 될 수 있습니다. Stepper는 Flow 내의 모든 네비게이션 동작을 트리거 할 수 있습니다.
- **Presentable**: 프리젠트 할 수 있는 것의 abstraction입니다(기본적으로 UIViewController 및 Flow는 Presentable). Presentable은 UIKit 호환 방식으로 네비게이션 단계를 처리하기 위해 Coordinator가 구독하는 리액티브 옵저버블을 제공합니다.
- **Flowable**: Presentable과 Stepper를 결합한 간단한 데이터 구조입니다. Coordinator에게 당신의 리액티브 메커니즘에서 새로운 Step을 만들어 줄 다음 요소가 무엇인지 알려줍니다.
- **Coordinator**: 개발자가 네비게이션 가능성을 나타내는 Flow와 Step의 적절한 조합을 정의한 후에 Coordinator의 임무는 이러한 결합을 일관된 방식으로 혼합하는 것입니다.

이 첫 번째 기사는 이 프레임워크의 개념적 및 이론적 측면을 다룹니다. 다음 기사에서는 RxFlow 에 대해 코드 샘플을 통해 보다 기술적인 관점에서 설명합니다.

이미 RxFlow 의 GitHub 레포를 탐색할 수 있습니다. 데모 애플리케이션이 포함되어  있습니다. https://github.com/RxSwiftCommunity/RxFlow